<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>eML Checker | eML Analysis Tool</title>
    <link rel="stylesheet" href="https://n4igme.github.io/assets/css/random/custom.css" />
</head>
<body>
    <div class="container">
        <h1>eML Checker</h1>
        <input type="file" id="emlFileInput">
        <pre id="output">Upload a .eml file to analyze its content.</pre>
    </div>

    <script>
        // Dangerous file extensions
        const DANGEROUS_EXTENSIONS = [
            'exe', 'bat', 'cmd', 'com', 'scr', 'vbs', 'js', 'jar',
            'zip', 'rar', '7z', 'msi', 'dll', 'sys', 'ps1', 'psm1',
            'doc', 'docx', 'xls', 'xlsx', 'ppt', 'pptx' // Office with macros
        ];

        // Common phishing phrases
        const PHISHING_PHRASES = [
            'verify your account', 'confirm your password', 'update payment',
            'unusual activity', 'click here immediately', 'act now',
            'urgent action required', 'verify identity', 'confirm credentials',
            'suspended', 'locked', 'restricted', 'temporary suspension',
            'reactivate your account', 'validate your information'
        ];

        document.getElementById('emlFileInput').addEventListener('change', function (event) {
            const file = event.target.files[0];
            const reader = new FileReader();

            reader.onload = function (e) {
                const content = e.target.result;
                parseEmlContent(content);
            };

            reader.readAsText(file);
        });

        function parseEmlContent(content) {
            const output = document.getElementById('output');
            output.textContent = '';

            // ===== ENHANCED HEADER PARSING =====
            output.textContent += '╔════════════════════════════════════════════════════════════╗\n';
            output.textContent += '║         EMAIL AUTHENTICATION & SECURITY ANALYSIS            ║\n';
            output.textContent += '╚════════════════════════════════════════════════════════════╝\n\n';

            const spf = parseSPF(content);
            const dkim = parseDKIM(content);
            const dmarc = parseAuthenticationResults(content);
            const originatingIP = extractOriginatingIP(content);
            const mailer = extractMailer(content);
            const returnPath = extractReturnPath(content);

            // Display SPF Results
            output.textContent += '━━━ SPF AUTHENTICATION ━━━\n';
            if (spf) {
                const status = spf.passed ? '✓ PASS' : '✗ FAIL';
                output.textContent += `Result: ${spf.result.toUpperCase()} ${status}\n`;
                output.textContent += `Details: ${spf.details}\n\n`;
            } else {
                output.textContent += `⚠ SPF: Not found in headers\n\n`;
            }

            // Display DKIM Results
            output.textContent += '━━━ DKIM SIGNATURE VERIFICATION ━━━\n';
            if (dkim.length > 0) {
                output.textContent += `Found: ${dkim.length} signature(s)\n`;
                dkim.forEach((sig, index) => {
                    output.textContent += `\n  Signature ${index + 1}:\n`;
                    output.textContent += `    Algorithm: ${sig.algorithm}\n`;
                    output.textContent += `    Version: ${sig.version}\n`;
                    output.textContent += `    Canonicalization: ${sig.canonicalization}\n`;
                });
                output.textContent += '\n';
            } else {
                output.textContent += `⚠ DKIM: Not found in headers\n\n`;
            }

            // Display DMARC Results
            output.textContent += '━━━ DMARC AUTHENTICATION RESULTS ━━━\n';
            if (dmarc) {
                output.textContent += `DMARC: ${dmarc.dmarc.toUpperCase()} ${dmarc.dmarc === 'pass' ? '✓' : '✗'}\n`;
                output.textContent += `  SPF: ${dmarc.spf.toUpperCase()} ${dmarc.spf === 'pass' ? '✓' : '✗'}\n`;
                output.textContent += `  DKIM: ${dmarc.dkim.toUpperCase()} ${dmarc.dkim === 'pass' ? '✓' : '✗'}\n\n`;
            } else {
                output.textContent += `⚠ DMARC: Not found in headers\n\n`;
            }

            // Display forensic headers
            output.textContent += '━━━ FORENSIC METADATA ━━━\n';
            if (originatingIP) {
                output.textContent += `Originating IP: ${originatingIP}\n`;
            }
            if (mailer) {
                output.textContent += `Email Client: ${mailer}\n`;
            }
            if (returnPath) {
                output.textContent += `Return-Path: ${returnPath}\n`;
            }
            if (!originatingIP && !mailer && !returnPath) {
                output.textContent += `No forensic headers found\n`;
            }
            output.textContent += '\n';

            // Extract Received headers for tracing the email path
            const receivedHeaders = extractReceivedHeaders(content);
            output.textContent += '━━━ EMAIL ROUTING PATH ━━━\n';
            if (receivedHeaders.length > 0) {
                receivedHeaders.forEach((header, i) => {
                    output.textContent += `${i + 1}. ${header.substring(0, 80)}${header.length > 80 ? '...' : ''}\n`;
                });
                output.textContent += '\n';
            } else {
                output.textContent += 'No Received headers found.\n\n';
            }

            // Extract and categorize email addresses
            const categorizedEmails = categorizeEmailAddresses(content);
            output.textContent += '━━━ EMAIL ADDRESSES ━━━\n';
            if (categorizedEmails.length > 0) {
                categorizedEmails.forEach(category => {
                    if (category.emails.size > 0) {
                        output.textContent += `${category.category}: ${[...category.emails].join(', ')}\n`;
                    }
                });
                output.textContent += '\n';
            }

            // ===== URL ANALYSIS =====
            output.textContent += '━━━ URL ANALYSIS ━━━\n';
            const urls = extractAndAnalyzeLinks(content);
            if (urls.length > 0) {
                urls.forEach((url, i) => {
                    output.textContent += `\n${i + 1}. Original: ${url.original}\n`;
                    output.textContent += `   Defanged: ${url.defanged}\n`;
                    if (url.suspiciousPatterns.length > 0) {
                        output.textContent += `   ⚠ Suspicious: ${url.suspiciousPatterns.join(', ')}\n`;
                    }
                });
                output.textContent += '\n';
            } else {
                output.textContent += 'No links found.\n\n';
            }

            // ===== ATTACHMENT ANALYSIS =====
            output.textContent += '━━━ ATTACHMENT ANALYSIS ━━━\n';
            const attachments = extractAttachments(content);
            if (attachments.length > 0) {
                attachments.forEach((att, i) => {
                    output.textContent += `\n${i + 1}. Filename: ${att.filename}\n`;
                    output.textContent += `   MIME Type: ${att.mimeType}\n`;
                    if (att.size) {
                        output.textContent += `   Size: ${formatFileSize(att.size)}\n`;
                    }
                    if (att.isDangerous) {
                        output.textContent += `   ⚠ DANGEROUS FILE TYPE: ${att.extension.toUpperCase()}\n`;
                    }
                });
                output.textContent += '\n';
            } else {
                output.textContent += 'No attachments found.\n\n';
            }

            // ===== EMAIL BODY ANALYSIS =====
            output.textContent += '━━━ EMAIL BODY ANALYSIS ━━━\n';
            const bodyAnalysis = analyzeEmailBody(content);

            if (bodyAnalysis.base64Content.length > 0) {
                output.textContent += 'Base64 Encoded Content Found:\n';
                bodyAnalysis.base64Content.forEach((b64, i) => {
                    output.textContent += `\n${i + 1}. Encoded: ${b64.substring(0, 60)}...\n`;
                    try {
                        const decoded = atob(b64);
                        output.textContent += `   Decoded: ${decoded.substring(0, 100)}${decoded.length > 100 ? '...' : ''}\n`;
                    } catch (e) {
                        output.textContent += `   Decoding failed\n`;
                    }
                });
                output.textContent += '\n';
            }

            if (bodyAnalysis.suspiciousPhrases.length > 0) {
                output.textContent += '⚠ PHISHING RED FLAGS:\n';
                bodyAnalysis.suspiciousPhrases.forEach(phrase => {
                    output.textContent += `  • "${phrase}"\n`;
                });
                output.textContent += '\n';
            } else {
                output.textContent += 'No suspicious phishing phrases detected.\n\n';
            }

            if (bodyAnalysis.spoofedSender) {
                output.textContent += '⚠ SENDER SPOOFING DETECTED:\n';
                output.textContent += `  From header domain: ${bodyAnalysis.spoofedSender.fromDomain}\n`;
                output.textContent += `  Return-Path domain: ${bodyAnalysis.spoofedSender.returnDomain}\n`;
                output.textContent += `  Mismatch: Possible sender spoofing\n\n`;
            }
        }

        // ===== ENHANCED HEADER PARSING FUNCTIONS =====
        function parseSPF(content) {
            const spfMatch = content.match(/Received-SPF:\s*(.+?)(?:\n|$)/i);
            if (!spfMatch) return null;

            const spfHeader = spfMatch[1];
            return {
                result: spfHeader.match(/(\w+)/)?.[1] || 'unknown',
                rawHeader: spfHeader,
                passed: /pass/i.test(spfHeader),
                details: spfHeader
            };
        }

        function parseDKIM(content) {
            const dkimMatches = content.match(/DKIM-Signature:([^]*?)(?=\n[A-Z-]+:|$)/gi) || [];

            return dkimMatches.map(dkim => {
                const versionMatch = dkim.match(/v=(\d+)/);
                const algorithmMatch = dkim.match(/a=([^;\s]+)/);
                const canonicalMatch = dkim.match(/c=([^;\s]+)/);

                return {
                    version: versionMatch?.[1] || 'unknown',
                    algorithm: algorithmMatch?.[1] || 'unknown',
                    canonicalization: canonicalMatch?.[1] || 'unknown',
                    rawHeader: dkim
                };
            });
        }

        function parseAuthenticationResults(content) {
            const authResultMatch = content.match(/Authentication-Results:\s*(.+?)(?:\n|$)/i);
            if (!authResultMatch) return null;

            const authHeader = authResultMatch[1];
            const dmarcMatch = authHeader.match(/dmarc=(\w+)/i);
            const spfMatch = authHeader.match(/spf=(\w+)/i);
            const dkimMatch = authHeader.match(/dkim=(\w+)/i);

            return {
                dmarc: dmarcMatch?.[1] || 'none',
                spf: spfMatch?.[1] || 'none',
                dkim: dkimMatch?.[1] || 'none',
                rawHeader: authHeader
            };
        }

        function extractOriginatingIP(content) {
            const ipMatch = content.match(/X-Originating-IP:\s*\[([^\]]+)\]/i);
            return ipMatch?.[1] || null;
        }

        function extractMailer(content) {
            const mailerMatch = content.match(/X-Mailer:\s*(.+?)(?:\n|$)/i);
            return mailerMatch?.[1] || null;
        }

        function extractReturnPath(content) {
            const returnMatch = content.match(/Return-Path:\s*<(.+?)>/i);
            return returnMatch?.[1] || null;
        }

        // ===== URL ANALYSIS FUNCTIONS =====
        function extractAndAnalyzeLinks(content) {
            const linkRegex = /https?:\/\/[^\s<>"{}|\\^`\[\]]+/g;
            const links = content.match(linkRegex) || [];

            return links.map(url => ({
                original: url,
                defanged: defangURL(url),
                suspiciousPatterns: detectSuspiciousURLPatterns(url)
            }));
        }

        function defangURL(url) {
            return url
                .replace(/http:\/\//i, 'hxxp://')
                .replace(/https:\/\//i, 'hxxps://')
                .replace(/\./g, '[.]');
        }

        function detectSuspiciousURLPatterns(url) {
            const patterns = [];

            // Check for IP-based URLs
            if (/https?:\/\/\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3}/.test(url)) {
                patterns.push('IP-based URL');
            }

            // Check for very long URLs (common in phishing)
            if (url.length > 100) {
                patterns.push('Unusually long URL');
            }

            // Check for encoded characters
            if (/%[0-9A-F]{2}/i.test(url)) {
                patterns.push('URL encoding detected');
            }

            // Check for suspicious subdomains (lookalike domains)
            const domain = url.match(/https?:\/\/([^\/]+)/)?.[1] || '';
            if (/paypa1|amaz0n|app1e|micr0soft|goog1e/i.test(domain)) {
                patterns.push('Potential homoglyph domain');
            }

            // Check for missing HTTPS
            if (url.startsWith('http://')) {
                patterns.push('Insecure HTTP');
            }

            return patterns;
        }

        // ===== ATTACHMENT ANALYSIS FUNCTIONS =====
        function extractAttachments(content) {
            const attachments = [];
            const boundaryMatches = content.match(/boundary="([^"]+)"/);

            if (boundaryMatches && boundaryMatches.length > 1) {
                const boundary = boundaryMatches[1];
                const parts = content.split(`--${boundary}`);

                parts.forEach(part => {
                    const filenameMatch = part.match(/filename="([^"]+)"/);
                    const mimeTypeMatch = part.match(/Content-Type:\s([^\s;]+)/);
                    const contentMatch = part.match(/Content-Transfer-Encoding:\s+base64\s+([^\n-]+)/);

                    if (filenameMatch && mimeTypeMatch) {
                        const filename = filenameMatch[1];
                        const extension = filename.split('.').pop().toLowerCase();
                        const isDangerous = DANGEROUS_EXTENSIONS.includes(extension);

                        attachments.push({
                            filename: filename,
                            mimeType: mimeTypeMatch[1],
                            extension: extension,
                            isDangerous: isDangerous,
                            size: contentMatch ? contentMatch[1].length : null
                        });
                    }
                });
            }

            return attachments;
        }

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return Math.round(bytes / Math.pow(k, i) * 100) / 100 + ' ' + sizes[i];
        }

        // ===== EMAIL BODY ANALYSIS FUNCTIONS =====
        function analyzeEmailBody(content) {
            const bodySection = content.split(/\n\n/)[content.split(/\n\n/).length - 1] || content;

            return {
                base64Content: findBase64Content(content),
                suspiciousPhrases: findSuspiciousPhrases(bodySection),
                spoofedSender: detectSpoofedSender(content)
            };
        }

        function findBase64Content(content) {
            // Look for base64 encoded content (long strings of alphanumeric, +, /, =)
            const base64Regex = /(?:[A-Za-z0-9+\/]{76}\r?\n)*[A-Za-z0-9+\/]{20,}={0,2}/g;
            return content.match(base64Regex) || [];
        }

        function findSuspiciousPhrases(text) {
            const found = new Set();
            PHISHING_PHRASES.forEach(phrase => {
                if (new RegExp(phrase, 'i').test(text)) {
                    found.add(phrase);
                }
            });
            return Array.from(found);
        }

        function detectSpoofedSender(content) {
            const fromMatch = content.match(/From:\s*(.+?)\s*<(.+?)>/);
            const returnMatch = content.match(/Return-Path:\s*<(.+?)>/);

            if (fromMatch && returnMatch) {
                const fromDomain = fromMatch[2].split('@')[1];
                const returnDomain = returnMatch[1].split('@')[1];

                if (fromDomain && returnDomain && fromDomain !== returnDomain) {
                    return {
                        fromDomain: fromDomain,
                        returnDomain: returnDomain
                    };
                }
            }

            return null;
        }

        function extractReceivedHeaders(content) {
            const receivedHeaders = [];
            const receivedRegex = /^Received: (.+?)(?=\n[A-Z]|$)/gm;
            let match;
            while ((match = receivedRegex.exec(content)) !== null) {
                receivedHeaders.push(match[1].replace(/\n\s+/g, ' '));
            }
            return receivedHeaders;
        }

        function categorizeEmailAddresses(content) {
            const emailAddresses = {
                sender: new Set(),
                receiver: new Set(),
                replyTo: new Set(),
                other: new Set()
            };

            const fromMatch = content.match(/From:\s(.+)/);
            const toMatch = content.match(/To:\s(.+)/);
            const replyToMatch = content.match(/Reply-To:\s(.+)/);

            if (fromMatch) {
                extractEmails(fromMatch[1]).forEach(email => emailAddresses.sender.add(email));
            }

            if (toMatch) {
                extractEmails(toMatch[1]).forEach(email => emailAddresses.receiver.add(email));
            }

            if (replyToMatch) {
                extractEmails(replyToMatch[1]).forEach(email => emailAddresses.replyTo.add(email));
            }

            const allEmails = extractEmails(content);
            allEmails.forEach(email => {
                if (!emailAddresses.sender.has(email) && !emailAddresses.receiver.has(email) && !emailAddresses.replyTo.has(email)) {
                    emailAddresses.other.add(email);
                }
            });

            return [
                { category: 'Sender', emails: emailAddresses.sender },
                { category: 'Receiver', emails: emailAddresses.receiver },
                { category: 'Reply To', emails: emailAddresses.replyTo },
                { category: 'Other', emails: emailAddresses.other }
            ];
        }

        function extractEmails(text) {
            const emailRegex = /[\w.+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}/g;
            return text.match(emailRegex) || [];
        }
    </script>
</body>
</html>